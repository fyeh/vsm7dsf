//-----------------------------------------------------------------
//  SOAP support
//
// Dec 2011, MF
//
// Copyright (c) 2011 by Cisco Systems, Inc.
// All rights reserved.
//------------------------------------------------------------------

/*
 *
 * NOTE 1:
 * To generate proxy (VSOmWebService.cs) from WSDL run svctool:
 *
 *  svcutil /async /l:C# /out:VSOmWebService.cs /s  /ser:Auto /n:*,Cisco.PSBU.VSOMWebService /edb /fault
 *       common_schema1.xsd Authentication_schema1.xsd Authentication.wsdl CameraMgmt_schema1.xsd CameraMgmt.wsdl LocationMgmt_schema1.xsd LocationMgmt.wsdl
 *       MultiPaneViewMgmt_schema1.xsd MultiPaneViewMgmt.wsdl UmsMgmt_schema1.xsd UmsMgmt.wsdl
 *
 * Note2:
 *
 * In some cases proxy file (VSOmWebService.cs) contains *TypeSpecified, in that case if it does not set to true, than base variable will NOT Serialize.
 * Example of correct usage:
 *
 *      ums.umsRedundancyConfig.serverRoleTypeSpecified = true;
 *      ums.umsRedundancyConfig.serverRoleType = haServerRoleTypeEnum.primary_server;
 *  If serverRoleTypeSpecified NOT set to true, than serverRoleType will not serialize !!!
 *
 *
 * Other solution for that problem:
 * http://blogs.microsoft.co.il/blogs/oshvartz/archive/2008/09/06/svcutil-generating-wcf-client-and-the-is-field-specified-issue.aspx
 * Change: change the serverRoleTypeSpecified fields from public to private.
 *
 * http://stackoverflow.com/questions/1680356/wcf-service-proxy-not-setting-fieldspecified-property/1681297#1681297
 *
 * if you have any fields (properties) marked as being nullable, the Add Service wizard in Visual Studio 2008
 * will also add a boolean field called fieldSpecified. So if you have a nullable field for, say, PhoneNumber,
 * you will have that and PhoneNumberSpecified. If you fill in the PhoneNumber field, but do not set PhoneNumberSpecified to true,
 * the field will not be sent to the WCF service.
 * From my little bit of research, if that Specified field is set to false, the property will not be included in the XML document sent to the WCF service.
 * If it is set to true, it will send it whether it’s null or not.
 * http://thecodemonk.com/2009/04/27/first-usage-of-wcf-and-specified-fields/
 *
 *
 * VSOM SOAP API init time may be be improved if(but I never tested it!):
 * 1) in solution properties Builds, select "Generate Serialization assembly  ON"
 * 2) In proxy file generated by svcutil comment out all lines which starts from "[System.Xml.Serialization.XmlIncludeAttribute"
 * 3) you must modify your project file by hand, but you can add the SGenUseProxyTypes property to your configuration to enable generation.
 *    (http://stackoverflow.com/questions/134224/generating-an-xml-serialization-assembly-as-part-of-my-build)
 *    Your project files configuration would end up looking something like this:
              <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
                <!-- Snip... -->
                <GenerateSerializationAssemblies>On</GenerateSerializationAssemblies>
                <SGenUseProxyTypes>false</SGenUseProxyTypes>
              </PropertyGroup>
              <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
                <!-- Snip... -->
                <GenerateSerializationAssemblies>On</GenerateSerializationAssemblies>
                <SGenUseProxyTypes>false</SGenUseProxyTypes>
              </PropertyGroup>
*/

using HelperLib;

namespace Cisco.PSBU.VSOMWebService
{
    using System;
    using System.Net;
    using System.Net.Security;
    using System.Runtime.InteropServices;
    using System.Security.Cryptography.X509Certificates;
    using System.ServiceModel;
    using System.ServiceModel.Channels;
    using System.ServiceModel.Description;
    using System.ServiceModel.Dispatcher;

    //By some reason, I am not able to add behavior/inspector AFTER invoking first method and add sessionID per object,
    // So, I will use static class, which allow ALL inspectors access to sessionID,
    // unfortunately that also limit to only one login simultaneously per client instance
    public static class AuthenticationInfo
    {
        public static string SessionId { get; internal set; }

        public static string HostName { get; internal set; }

        public static string UserName { get; internal set; }

        public static string Domain { get; internal set; }

        public static string Password { get; internal set; }

        public static bool Secure { get; set; }

        public static bool Ignore { get; set; }

        public static string CertValidationError { get; internal set; }

        public static void SetAllAuthParams(string hostname, string domain, string username, string password, bool secure, bool ignore)
        {
            HostName = hostname;
            Domain = domain;
            UserName = username;
            Password = password;

            Secure = secure;  // use HTTPS
            Ignore = ignore;  // ignore certificate validation errors
            CertValidationError = "";
        }
    }

    public class VsomServices
    {
        private static readonly object padlock = new object();
        private static VsomServices vsomService = null; // prevent calling VsomServices multiple times

        public VsomServices(string hostname, string domain, string username, string password, bool secure, bool ignore)
        { // DOTO: Make it singleton
            lock (padlock)
            {
                if (vsomService == null)  // we want instantiate services only once
                {
                    AuthenticationInfo.SetAllAuthParams(hostname, domain, username, password, secure, ignore);  // ignore server certificate

                    TraceHelper.WriteInfo(string.Format("Start Services initialization, secure = {0}", secure));
                    AuthService = BaseService<AuthenticationClient, IAuthentication>.GetClientService(AuthenticationInfo.HostName, "authentication/v1_0");

                    session sid = null;
                    AuthenticationInfo.CertValidationError = "Valid";
                    try
                    {
                    sid = AuthService.login(username, password, domain);
                    if (secure == true) { TraceHelper.WriteInfo(string.Format("Certificate validation: {0} \n", AuthenticationInfo.CertValidationError)); }
                    AuthenticationInfo.SessionId = sid.uid; // set global SessionId (will used in inspector's to overwrite HTTP header)

                    TraceHelper.WriteInfo(string.Format("Login sessionID={0} \n", sid.uid));

                    // supported services
                    LocationService = BaseService<LocationMgmtClient, ILocationMgmt>.GetClientService(AuthenticationInfo.HostName, "location/v1_0");
                    CameraService = BaseService<CameraMgmtClient, ICameraMgmt>.GetClientService(AuthenticationInfo.HostName, "camera/v1_0");
                    MultiPaneService = BaseService<MultiPaneViewMgmtClient, IMultiPaneViewMgmt>.GetClientService(AuthenticationInfo.HostName, "multiPaneView/v1_0");
                    AlertService = BaseService<AlertMgmtClient, IAlertMgmt>.GetClientService(AuthenticationInfo.HostName, "alert/v1_0");
                    EventService = BaseService<EventMgmtClient, IEventMgmt>.GetClientService(AuthenticationInfo.HostName, "event/v1_0");

                    // not supported services
                    UmsService = BaseService<UmsMgmtClient, IUmsMgmt>.GetClientService(AuthenticationInfo.HostName, "mediaserver/v1_0");
                    JobService = BaseService<JobMgmtClient, IJobMgmt>.GetClientService(AuthenticationInfo.HostName, "job/v1_0");
                    TemplateService = BaseService<DeviceTemplateMgmtClient, IDeviceTemplateMgmt>.GetClientService(AuthenticationInfo.HostName, "devicetemplate/v1_0");
                    MapService = BaseService<MapMgmtClient, IMapMgmt>.GetClientService(AuthenticationInfo.HostName, "map/v1_0");
                    EncoderService = BaseService<EncoderMgmtClient, IEncoderMgmt>.GetClientService(AuthenticationInfo.HostName, "encoder/v1_0");
                    DeviceCapabilityService = BaseService<DeviceCapabilityMgmtClient, IDeviceCapabilityMgmt>.GetClientService(AuthenticationInfo.HostName, "devicecapability/v1_0");
                    DeviceHealthMgmtService = BaseService<DeviceHealthMgmtClient, IDeviceHealthMgmt>.GetClientService(AuthenticationInfo.HostName, "devicehealth/v1_0");
                    TraceHelper.WriteInfo("All Services initialized \n");
                    }
                    catch (Exception ex)
                    {
                        ExceptionHelper.HandleException(ex);
                    }
                }
            }
        }

        // supported services
        public AuthenticationClient AuthService { get; internal set; }

        public LocationMgmtClient LocationService { get; internal set; }

        public CameraMgmtClient CameraService { get; internal set; }

        public MultiPaneViewMgmtClient MultiPaneService { get; internal set; }

        public AlertMgmtClient AlertService { get; internal set; }

        public EventMgmtClient EventService { get; internal set; }

        //non supported services
        public UmsMgmtClient UmsService { get; internal set; }

        public DeviceTemplateMgmtClient TemplateService { get; internal set; }

        public JobMgmtClient JobService { get; internal set; }

        public MapMgmtClient MapService { get; internal set; }

        public EncoderMgmtClient EncoderService { get; internal set; }

        public DeviceCapabilityMgmtClient DeviceCapabilityService { get; internal set; }

        public DeviceHealthMgmtClient DeviceHealthMgmtService { get; internal set; }

    }

    public static class baseObject2Ref
    {
        public static baseObjectRef bO2Ref(baseObject bO)
        {
            baseObjectRef oR = new baseObjectRef();
            oR.refUid = bO.uid;
            oR.refName = bO.name;
            oR.refObjectType = bO.objectType;
            oR.refObjectTypeSpecified = true;   // This will make MS serializer happy
            return oR;
        }
    }
   
    [ClassInterface(ClassInterfaceType.AutoDual)]
    internal abstract class BaseService<TClient, TInterface>
        where TClient : ClientBase<TInterface>, new()
        where TInterface : class
    {
        public static TClient GetClientService(string host, string service)
        {
            string protocol;
            if (AuthenticationInfo.Secure == true)
            {
                protocol = "https";
                // validate cert by calling a our function
                ServicePointManager.ServerCertificateValidationCallback += new RemoteCertificateValidationCallback(ValidateRemoteCertificate);
            }
            else { protocol = "http"; }

            string serviceAddress = string.Format("{0}://{1}/ismserver/soap/{2}", protocol, host, service);
            TClient result = Activator.CreateInstance(typeof(TClient), new object[] { new BasicHttpBinding(), new EndpointAddress(serviceAddress) }) as TClient;
            ClientBase<TInterface> client = result as ClientBase<TInterface>;
            BasicHttpBinding binding = (BasicHttpBinding)client.Endpoint.Binding;
            TimeSpan timeOut = new TimeSpan(0, 5, 0);
            binding.SendTimeout = timeOut; binding.CloseTimeout = timeOut; binding.ReceiveTimeout = timeOut;
            binding.Security.Transport.ClientCredentialType = HttpClientCredentialType.None;
            if (AuthenticationInfo.Secure == true) { binding.Security.Mode = BasicHttpSecurityMode.Transport; }//HTTPS only
            binding.ReaderQuotas.MaxNameTableCharCount = int.MaxValue; // see:  http://msdn.microsoft.com/en-us/library/ee767691.aspx
            binding.MaxReceivedMessageSize = int.MaxValue;
            CookieBehavior cookieBehavior = new CookieBehavior();
            client.Endpoint.Behaviors.Add(cookieBehavior);
            return result;
        }

        // callback used to validate the certificate in an SSL conversation, we need it to able show certificate validation errors
        private static bool ValidateRemoteCertificate(object sender, X509Certificate cert, X509Chain chain, SslPolicyErrors policyErrors)
        {
            if (policyErrors == SslPolicyErrors.None) { return true; }
            else
            {
                AuthenticationInfo.CertValidationError = policyErrors.ToString(); // save certificate validation error
                if (AuthenticationInfo.Ignore == true) { return true; } // ignore certificate validations error
            }

            return false;
        }
    }

    internal class CookieInspector : IClientMessageInspector
    {
        public void AfterReceiveReply(ref Message reply, object correlationState)
        {
        }

        public object BeforeSendRequest(
                ref Message request,
                IClientChannel channel)
        {
            HttpRequestMessageProperty messageProperty;

            if (request.Properties.ContainsKey(HttpRequestMessageProperty.Name))
            {
                messageProperty = (HttpRequestMessageProperty)request.Properties[
                    HttpRequestMessageProperty.Name
                ];
            }
            else
            {
                messageProperty = new HttpRequestMessageProperty();
                request.Properties.Add(
                    HttpRequestMessageProperty.Name,
                    messageProperty
                );
            }

            // Set  headers for now...
            //messageProperty.Headers.Add(HttpRequestHeader.Cookie, "Bob=Great");
            messageProperty.Headers.Add("x-ism-sid", AuthenticationInfo.SessionId);
            return null;
        }
    }

    internal class CookieBehavior : IEndpointBehavior
    {
        public void AddBindingParameters(
                ServiceEndpoint endpoint,
                BindingParameterCollection bindingParameters)
        {
        }

        public void ApplyClientBehavior(
                ServiceEndpoint endpoint,
                ClientRuntime clientRuntime)
        {
            CookieInspector cookieInspector = new CookieInspector();
            clientRuntime.MessageInspectors.Add(cookieInspector);
        }

        public void ApplyDispatchBehavior(
                ServiceEndpoint endpoint,
                EndpointDispatcher endpointDispatcher)
        {
        }

        public void Validate(ServiceEndpoint endpoint)
        {
        }
    }
}